\documentclass{emulateapj}

%\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{graphicx}
\usepackage[backref,breaklinks,colorlinks,citecolor=blue]{hyperref}
\usepackage[all]{hypcap}
\usepackage{amsmath}
\usepackage{verbatim}

\usepackage{enumitem}
\setitemize{itemsep=0pt}
%\setlist{nolistsep} %really really no itemsep

%\usepackage{url}
%\graphicspath{{figures/}}

\usepackage{listings}
\lstset{language=Python,
        basicstyle=\footnotesize\ttfamily, %smaller font for blocks of code
        %numbers=left,
        %xleftmargin=2em,
        showspaces=false,
        showstringspaces=false,
        tabsize=2,
        breaklines=false,
        breakatwhitespace=true,
        identifierstyle=\ttfamily,
        keywordstyle=\bfseries\color[rgb]{0.133,0.545,0.133}, %forestgreen
        commentstyle=\bfseries\sl\color[rgb]{0.372, 0.619, 0.627}, %cadetblue
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        %keywordstyle=\bfseries\color[rgb]{0.133,0.545,0.133},
        %commentstyle=\color[rgb]{0.133,0.545,0.133},
        %stringstyle=\color[rgb]{0.627,0.126,0.941},
    }

\lstdefinestyle{codeintext}{language=Python, basicstyle=\ttfamily} %normal size font for in text
\newcommand{\code}{\lstinline[style=codeintext]}

\newcommand{\hcode}{\large\normalfont\texttt} %code in titles, section headers, etc

\newcommand{\attn}[2][red]{\textcolor{#1}{\textit{#2}}}
\renewcommand*{\backref}[1]{[#1]}

\begin{document}

\title{\MakeLowercase{\hcode{cluster-lensing}}: a \hcode{P}\MakeLowercase{\hcode{ython}} Package for Galaxy Clusters and Miscentering}

\author{
Jes Ford\altaffilmark{1},
Jake VanderPlas\altaffilmark{1}
}
\altaffiltext{1}{eScience Institute, University of Washington \\  \hspace*{0.5cm}contact: \email{jesford@uw.edu}}

\shorttitle{\hcode{cluster-lensing}}
\shortauthors{Ford \& VanderPlas}


\begin{abstract}
We describe a new open source package for calculating properties of galaxy clusters, including NFW halo profiles with and without the effects of cluster miscentering. This pure-\code{Python} package, \code{cluster-lensing}, provides well-documented and easy-to-use classes and functions for calculating cluster scaling relations, including mass-richness and mass-concentration relations from the literature, as well as the surface mass density $\Sigma(R)$ and differential surface mass density $\Delta\Sigma(R)$ profiles, probed by weak lensing magnification and shear, respectively. Galaxy cluster miscentering is especially a concern for stacked weak lensing shear studies of galaxy clusters, where offsets between the assumed and the true underlying matter distribution
This software has been developed and released in a public GitHub repository, and is licensed under the permissive free MIT license. The \code{cluster-lensing} package can be downloaded through the Python Package Index, \url{https://pypi.python.org/pypi/cluster-lensing}, or directly from GitHub, at \url{https://github.com/jesford/cluster-lensing}. Full documentation is available at \url{http://jesford.github.io/cluster-lensing/}.
\end{abstract}

\keywords{methods: data analysis -- methods: numerical -- galaxies: clusters: general -- gravitational lensing: weak -- dark matter}

\setcounter{section}{0}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{intro}

Clusters of galaxies are the largest gravitationally collapsed structures to have formed in the history of the universe.  As such, they are interesting both from a cosmological as well as an astrophysics perspective. In the former case, the galaxy cluster number density as a function of mass (the cluster mass function) is a probe of cosmological parameters including the fractional matter density $\Omega_{\rm m}$ and the normalization of the matter power spectrum $\sigma_8$. Astrophysically, the deep potential wells of galaxy clusters are environments useful for testing theories of general relativity, galaxy evolution, and gas and plasma physics, among other things \citep{Voit05}. 

The common thread among these diverse investigations is the requisite knowledge of the mass of the galaxy cluster, which is largely composed of its invisible dark matter halo. Although many techniques exist for estimated the total mass of these systems, weak lensing has emerged as somewhat of a gold standard, since it is sensitive to the mass itself, and not to the dynamical state or other biased tracers of the underlying mass. Scaling relations between weak lensing derived masses, and other observables, including richness, X-ray luminosity and temperature, for examples, are typically calibrated from large surveys and extrapolated to clusters for which gravitational lensing measurements are impossible or unreliable. Since weak lensing masses are often considered the ``true'' masses, against which other estimates are compared \citep[e.g.][]{Leauthaud10, vonderLinden14, Hoekstra15}, it is paramount that cluster masses from weak lensing modeling are as unbiased as possible.

For stacked weak lensing measurements of galaxy clusters, an important source of bias in fitting a mass model is the inclusion of the effect of miscentering offsets. Miscentering occurs when the center of the mass distribution, the dark matter halo, does not perfectly coincide with the assumed center around which tangential shear (or magnification) profiles are being measured. Candidate centers for galaxy clusters are necessarily chosen from observational proxies, and often include a single galaxy, such as the brightest or most massive cluster galaxy, or the centroid of some extended quantity like the peak of X-ray emission or average of galaxy positions \citep{George12}. The particular choice of center may be offset from the true center due to interesting physical processes such as recent mergers and cluster evolution, or simply due to misidentification of the proxy of interest \citep{Johnston07}. 

The miscentering effect on the stacked weak lensing profile can be included in a proper modeling of the measurement, as done in \citet{Johnston07, Mandelbaum10, Oguri11, George12, Sehgal13, Oguri14, Ford14, Ford15, Simet16}. The inclusion of this effect commonly assumes a form for the distribution of offsets, such as a Rayleigh distribution in radius (which represents a 2D Gaussian in the plane of the sky), which is convolved with the centered profile. Software for performing the integrations for the miscentered weak lensing profiles was developed in order to produce results in \citet{Ford14, Ford15}, and has recently been publicly released to the astronomical community.\footnote{\url{https://github.com/jesford/cluster-lensing}}

When many different gravitational lenses are stacked, as is often necessary to increase signal-to-noise for weak lensing measurements, care must be taken in the interpretation of the average signal. The issue here is that the (differential) surface mass density is not a linear function of the mass, so the average of many stacked profiles does not directly yield the average mass of the lens sample. Care must be taken to consider the underlying distribution of cluster masses as well as the redshifts of lenses and sources, all of which affect the amplitude of the measured lensing profile. One approach to this is to use a so-called composite-halo approach \citep[e.g.][]{Hildebrandt11, Ford12, Ford14, Ford15, Simet16}, where profiles are calculated for all individual lens objects and then averaged together to create a model that can be fit to the measurement. The \code{ClusterEnsemble()} class discussed in Section \ref{clusters} is designed with this approach in mind.

A popular model for the dark matter distribution in a gravitationally collapsed halo, such as a galaxy cluster, is the Navarro, Frenk, and White (NFW) model. This density profile (given in Equation \ref{nfw3d} below) was determined from numerical simulations, including the dissipationless collapse of density fluctuations under gravity \citep{nfw97}. The simpler Singular Isothermal Sphere density model, which only has one free parameter in contrast to the two for NFW, does not tend to fit the inner profiles of halos well and is also unphysical in that the total mass diverges \citep{Schneider06_WeakGravLens}. Other models such as the generalized-NFW and the Einasto profile tend to better describe the full radial distribution of dark matter in halos, at the expense of adding a third parameter to characterize the inner slope of the density profiles \citep[see {\emph e.g.} discussion in][]{Dutton14}. In the software package presented in this work we only include the standard 2-parameter NFW model, but future work should make alternative models available as well.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Description of the Code}
\label{code}

In this section we describe each of the individual modules and a few of the functions available in the \code{cluster-lensing} package. Much of this content comes directly from pages within the online documentation.\footnote{\url{http://jesford.github.io/cluster-lensing/}} Throughout the modules, dimensionful quantities are labelled as such by means of the \code{astropy.units} package \citep{astropy13}.

\begin{itemize} 
\item Purpose and general use.
\item Relation to existing code
\item \code{SurfaceMassDensity()} class, generic to all NFW halos
\item \code{ClusterEnsemble()} class
\item mass-richness functions
\item mass-concentration functions
\item We use units from the \code{astropy.units} package \citep{astropy13}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\normalfont{\hcode{nfw.py}}}
\label{nfw}

The \code{nfw.py} module contains a single class called \code{SurfaceMassDensity()}, which computes the surface mass density $\Sigma(R)$ and the differential surface mass density $\Delta\Sigma(R)$ using the class methods \code{sigma_nfw()} and \code{deltasigma_nfw()}, respectively. These profiles are calculated according to the analytical formulas first derived by \citet{Wright00}, assuming the spherical NFW model, and can be applied to any dark matter halo: \emph{this module is not specific to galaxy clusters}. 

The 3-dimensional density profile of an NFW halo is given by 
\begin{equation}\label{nfw3d}
\rho(r) = \frac{\delta_{\rm c} \rho_{\rm crit}}{(r/r_{\rm s})(1+r/r_{\rm s})^2},
\end{equation}
where $r_{\rm s}$ is the cluster scale radius, $\delta_{\rm c}$ is the characteristic halo overdensity, and $\rho_{\rm crit} = \rho_{\rm crit}(z)$ is the critical energy density of the universe at the lens redshift. These three parameters\footnote{or, in the case of calculating multiple NFW halos at once, three array-like objects representing each of these parameters} must be specified when instantiating the class \code{SurfaceMassDensity()}, via the arguments \code{rs}, \code{delta_c}, and \code{rho_crit}, respectively. The units on \code{rs} are assumed to be Mpc, \code{delta_c} is dimensionless, and \code{rho_crit} is in $M_{\odot}/{\rm Mpc}/{\rm pc}^2$, although the actual inclusion of the \code{astropy.units} on these variables is optional. The user will probably also want to choose the radial bins for the calculation, which are specified via the keyword argument \code{rbins}, in Mpc. The surface mass density is the integral along the line-of-sight of the 3-dimensional density:
\begin{equation}
\Sigma(R) = 2 \int_0^{\infty} \rho(R,y) {\rm d}y.
\end{equation}
Here $R$ is the projected radial distance (in the plane of the sky).  

We can adopt the dimensional radius $x \equiv R/r_{\rm s}$ and, following from \citet{Wright00}, show that:
\begin{equation}\label{sigma}
\Sigma(x) = 2 r_{\rm s} \delta_{\rm c} \rho_{\rm crit} f(x),
\end{equation}
where $f(x) = $
\begin{equation}
    \begin{cases}
        \frac{1}{x^2 - 1} \left( 1 - \ln{ \left[ \frac{1}{x} + \sqrt{\frac{1}{x^2} - 1} \right]} / \sqrt{1 - x^2} \right), & \text{for } x < 1; \\
        1/3, & \text{for } x = 1; \\
        \frac{1}{x^2 - 1} \left( 1 - \arccos{(1/x)} / \sqrt{x^2 - 1} \right), & \text{for } x > 1.
    \end{cases}
\end{equation}

The differential surface mass density probed by shear is calculated from the definition
\begin{equation}\label{dsigma}
\Delta\Sigma(x) \equiv  \overline{\Sigma}(<x) - \Sigma(x),
\end{equation}
where
\begin{equation}\label{sigbar}
\overline{\Sigma}(<x) = \frac{2}{x^2} \int_0^{x} \Sigma(x') x' {\rm d}x'.
\end{equation}

We can rewrite the differential surface mass density in the form in which it is computed in \code{nfw.py}:
\begin{equation}
     \Delta\Sigma(x) = r_{\rm s} \delta_{\rm c} \rho_{\rm crit} g(x),
\end{equation}
where  $g(x) = $
\begin{equation}
    \begin{cases}

    \left[ \frac{4 / x^2 + 2/ (x^2 - 1)}{\sqrt{1 - x^2}} \right] \ln \left( \frac{1 + \sqrt{(1-x) / (1+x)} }{1 - \sqrt{(1-x) / (1+x)} } \right) \\ + \frac{4}{x^2} \ln \frac{x}{2} - \frac{2}{(x^2 - 1)}, & \text{for } x < 1; \\
    
    (10/3) + 4 \ln(1/2), & \text{for } x = 1; \\
    
    \left[ \frac{8}{x^2 \sqrt{x^2 - 1}} + \frac{4}{(x^2 - 1)^{3/2}} \right] \arctan\sqrt{\frac{x-1}{1+x}} \\ + \frac{4}{x^2} \ln \frac{x}{2} - \frac{2}{(x^2 - 1)}, & \text{for } x > 1.

    \end{cases}
\end{equation}

Running \code{sigma_nfw()} or \code{deltasigma_nfw()}, with only a specification of halo properties \code{rs}, \code{delta_c}, \code{rho_crit}, and radial bins \code{rbins}, will lead to the calculation of halo profiles according to Equations \ref{sigma} and \ref{dsigma} outlined above. 

%---------- code ----------
\begin{lstlisting}
from clusterlensing import SurfaceMassDensity
rbins = [0.1, 0.5, 1.0, 2.0, 4.0] # Mpc
smd = SurfaceMassDensity(rs=[0.1], 
                         rho_crit=[0.2], 
                         delta_c=[9700.], 
                         rbins=rbins)
sigma = smd.sigma_nfw()
# surface mass density with default units
sigma[0]
<Quantity [ 129.33333333, 11.64751032, 3.33992059, 
0.89839601, 0.23327149] solMass / pc2>
# surface mass density with no units
sigma[0].value
array([ 129.33333333, 11.64751032, 3.33992059, 
0.89839601, 0.23327149])
\end{lstlisting}
%----------------------------

These are the standard centered NFW profiles, under the assumption that the peak of the halo density distribution perfectly coincides with the identified halo center. This may not be a good assumption, however, and the user can instead run these calculations for miscentered halos by specifying the optional input parameter \code{offsets}. This parameter sets the width of a distribution of centroid offsets, assuming a 2-dimensional Gaussian distribution on the sky. This offset distribution is equivalent to, and implemented in code as, a uniform distribution in angle and a Rayleigh probability distribution in $R$:
\begin{equation}\label{PofR}
P(R_{\mathrm{off}})=\frac{R_{\mathrm{off}}}{\sigma_{\mathrm{off}}^2}\ \mathrm{exp}\bigg[-\frac{1}{2}\bigg(\frac{R_{\mathrm{off}}}{\sigma_{\mathrm{off}}}\bigg)^2\ \bigg].
\end{equation}
The parameter \code{offsets} is equivalent to $\sigma_{\rm off}$ in this equation.

%---------- code ----------
\begin{lstlisting}
from clusterlensing import SurfaceMassDensity
rbins = [0.1, 0.5, 1.0, 2.0, 4.0]
# single miscentered halo profile
smd = SurfaceMassDensity(rs=[0.1], 
                         rho_crit=[0.2], 
                         delta_c=[9700.], 
                         rbins=rbins,
                         offsets=[0.3])
sigma = smd.sigma_nfw()
sigma[0]
<Quantity [ 38.60655298, 17.57285034, 4.11253461, 
0.93809627, 0.23574031] solMass / pc2>
# example calculating multiple profiles
smd = SurfaceMassDensity(rs=[0.1,0.2,0.2], 
                         rho_crit=[0.2,0.2,0.2], 
                         delta_c=[9700,9700,9000], 
                         rbins=rbins, 
                         offsets=[0.3,0.3,0.3])
sigma = smd.sigma_nfw()
sigma 
<Quantity [[  38.60655298,  17.57285034,   4.11253461,   0.93809627,   0.23574031],
           [ 181.91820855,  92.86651598,  27.34020647,   6.94677803,  1.81488253],
           [ 168.79009041,  86.16480864,  25.36720188,   6.44546415,  1.68391163]] solMass / pc2>
\end{lstlisting}
%----------------------------

The miscentered surface mass density profiles are given by the centered profiles (Equations \ref{sigma} and \ref{dsigma}), convolved with the offset distribution (Equation \ref{PofR}). We follow the offset halo formalism first written down by \citet{Yang06}, and applied to cluster miscentering by, {\textit e.g.} \citet{Johnston07, George12, Ford14, Ford15, Simet16}. Specifically, we calculate the offset surface mass density $\Sigma^{\rm off}$ as follows:
\begin{equation}
\Sigma^{\rm off}(R) = \int_{0}^{\infty} \Sigma(R | R_{\rm off})\ P(R_{\rm off})\ {\rm d}R_{\rm off}
\end{equation}
\begin{equation}
\Sigma(R|R_{\mathrm{off}})=\frac{1}{2\pi}\int_{0}^{2\pi}\Sigma(r) \mathrm{d}\theta
\end{equation}
Here $r = \sqrt{R^2+R_{\mathrm{off}}^2-2RR_{\mathrm{off}}\cos(\theta)}$ and $\theta$ is the azimuthal angle \citep{Yang06}. The $\Delta\Sigma^{\rm off}$ profile is calculated from $\Sigma^{\rm off}$, in analogy with Equations \ref{dsigma} and \ref{sigbar}.

%---------- code ----------
\begin{lstlisting}
from clusterlensing import SurfaceMassDensity
rbins = [0.1, 0.5, 1.0, 2.0, 4.0]
# perfectly centered DeltaSigma profile
smd = SurfaceMassDensity(rs=[0.1], 
                         rho_crit=[0.2], 
                         delta_c=[9700.], 
                         rbins=rbins)
deltasigma = smd.deltasigma_nfw()
deltasigma[0]
<Quantity [ 108.78445455, 25.47093418, 10.29627483, 
3.71631903, 1.23840727] solMass / pc2>
# miscentered DeltaSigma profile
rbins = [0.1, 0.5, 1.0, 2.0, 4.0]
smd = SurfaceMassDensity(rs=[0.1], 
                         rho_crit=[0.2], 
                         delta_c=[9700.], 
                         rbins=rbins,
                         offsets=[0.3])
deltasigma = smd.deltasigma_nfw()
deltasigma[0]
<Quantity [ 0.71370144, 9.35821817, 8.90118561, 
3.6475417, 1.23610325] solMass / pc2>
\end{lstlisting}
%----------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\hcode{cofm.py}}
\label{cofm}

The \code{cofm.py} module currently contains three functions, each of which calculates halo concentration from mass, redshift, and cosmology, according to a prescription given in the literature. These functions are \code{c_DuttonMaccio()} \citep[for calculations following][]{Dutton14}, \code{c_Duffy()} \citep[following][]{Duffy08}, and \code{c_Prada()} \citep[for][]{Prada12}. Halo mass-concentration relations are an area of active research, and there have been discrepancies between results from different observations and simulations, and disagreement surrounding the best choice of model \citep[see {\emph e.g.}][]{Dutton14, Klypin16}. We do not aim to join this discussion here, but focus on outlining the functionality provided by the \code{cluster-lensing} package, for calculating these different concentration values.

All three functions require two input parameters (scalars or array-like inputs), which are the halo redshift(s) \code{z} and the halo mass(es) \code{m}. Specifically, the latter is assumed to correspond to the $M_{200}$ mass definition, in units of solar masses. $M_{200}$ is the mass interior to a sphere of radius $r_{200}$, within which the average density is $200\rho_{\rm crit}(z)$. 

The default cosmology used is from the measurements by the \citet{PlanckXVI}, which is imported from the module \code{astropy.cosmology.Planck13}. However, the user can specify alternative cosmological parameters. For calculating concentration according to either the \citet{Duffy08} or the \citet{Dutton14} prescription, the only cosmological parameter required is the Hubble parameter, which can be passed into \code{c_Duffy()} or \code{c_DuttonMaccio()} as the keyword argument \code{h}. For the \citet{Prada12} concentration, the user would want to specify \code{Om_M} and \code{Om_L} (the fractional energy densities of matter and the cosmological constant) in addition to \code{h}, in the call to \code{c_Prada()}.

The \code{c_DuttonMaccio()} calculation of concentration is done according to the power-law
\begin{equation}
\log_{10} c_{200} = a + b \log_{10}(M_{200} / [10^{12} h^{-1} M_{\odot}]), 
\end{equation}
where
\begin{equation}
a = 0.52 + 0.385 \cdot {\rm exp}[-0.617\ z^{1.21}],
\end{equation}
\begin{equation}
b = -0.101 + 0.206 z.
\end{equation}
The above three equations map to Equations 7, 11, and 10, respectively in \citet{Dutton14}. The values in these expressions were determined from simulations of halos between $0 < z < 5$, spanning over 5 orders of magnitude in mass, and shown to match observational measurements of low-redshift galaxies and clusters \citep{Dutton14}. This concentration-mass relation is the default one used by the \code{clusters.py} module

%---------- code ----------
\begin{lstlisting}
from clusterlensing import cofm
# single 10**14 Msun halo at z=1
cofm.c_DuttonMaccio(0.1, 1e14)
array([ 5.13397936])
# example with multiple halos
cofm.c_DuttonMaccio([0.1, 0.5], [1e14, 1e15])
array([ 5.13397936,  3.67907305])
\end{lstlisting}
%----------------------------

The concentration calculation in \code{c_Duffy()} is
\begin{equation}\label{c_Duffy}
c_{200} = A \cdot (M_{200} / M_{\rm pivot})^B \cdot (1 + z)^C,
\end{equation}
where
\begin{equation}
\{A, B, C\} = \{5.71, -0.084, -0.47\},
\end{equation}
\begin{equation}
M_{\rm pivot} = 2 \times 10^{12}\ h^{-1} M_{\odot}.
\end{equation}
Equation \ref{c_Duffy} in this work maps to Equation 4 in \citet{Duffy08}. The values for $A$, $B$, and $C$ can be found in Table 1 of that work, where they are specific to the ``full'' (relaxed and unrelaxed) sample of simulated NFW halos, spanning the redshift range $0 < z < 2$. $M_{\rm pivot}$ can be found in the caption of Table 1 as well. One caveat with this relation is that the cosmology used in creating the \citet{Duffy08} simulations was that of the now outdated WMAP5 experiment \citep{WMAP5}.

%---------- code ----------
\begin{lstlisting}
from clusterlensing import cofm
# default cosmology, h=0.6777
cofm.c_Duffy([0.1, 0.5], [1e14, 1e15])
array([ 4.06126115, 2.89302767])
# with h=1
cofm.c_Duffy([0.1, 0.5], [1e14, 1e15], h=1)
array([ 3.93068341, 2.80001099])
\end{lstlisting}
%----------------------------


The \code{c_Prada()} concentration calculation is much more complex, and written in terms of $\sigma(M_{200}, x_{\rm p})$, the rms fluctuation of the density field. The \citet{Prada12} halo concentration is given by\footnote{we use the subscript ``p'' to distinguish some variables in the equations from \citet{Prada12} from those in the current work}
\begin{equation}\label{c_Prada}
\begin{split}
c_{200} = 2.881 B_0 (x_{\rm p}) \bigg[ \left( \frac{B_1(x_{\rm p}) \sigma(M_{200},x_{\rm p})}{1.257} \right)^{1.022} + 1 \bigg] \\
\times\ {\rm exp}\left( \frac{0.06}{[B_1(x_{\rm p}) \sigma(M_{200},x_{\rm p}) ]^2} \right).
\end{split}
\end{equation}
The cosmology and redshift dependence is encoded by the variable $x_{\rm p}$, which is  
\begin{equation}
x_{\rm p} = \left( \frac{\Omega_{\Lambda, 0}}{\Omega_{{\rm m}, 0}} \right)^{1/3} (1 + z)^{-1}.
\end{equation}
The functions within Equation \ref{c_Prada} are as follows:
\begin{equation}
\sigma(M_{200},x_{\rm p}) = D(x_{\rm p}) \frac{16.9 y_{\rm p}^{0.41}}{1 + 1.102 y_{\rm p}^{0.2} + 6.22 y_{\rm p}^{0.333}}
\end{equation}
\begin{equation}
y_{\rm p} \equiv \frac{10^{12} h^{-1} M_{\odot}}{M_{200}}
\end{equation}
\begin{equation}
D(x_{\rm p}) = \frac{5}{2} \left( \frac{\Omega_{{\rm m}, 0}}{\Omega_{\Lambda, 0}} \right)^{1/3} \frac{\sqrt{1 + x_{\rm p}^3}}{x_{\rm p}^{3/2}} \int_0^{x_{\rm p}} \frac{x^{3/2} {\rm d}x}{(1 + x^3)^{3/2}}
\end{equation}
\begin{equation}
B_0(x_{\rm p}) = \frac{c_{\rm min}(x_{\rm p})}{c_{\rm min}(1.393)}
\end{equation}
\begin{equation}
B_1(x_{\rm p}) = \frac{\sigma^{-1}_{\rm min}(x_{\rm p})}{\sigma^{-1}_{\rm min}(1.393)}
\end{equation}
\begin{equation}
c_{\rm min}(x_{\rm p}) = 3.681 + 1.352 \bigg[ \frac{1}{\pi} \arctan[6.948 (x_{\rm p} - 0.424)] + \frac{1}{2} \bigg]
\end{equation}
\begin{equation}
\sigma^{-1}_{\rm min}(x_{\rm p}) = 1.047 + 0.599 \bigg[ \frac{1}{\pi} \arctan[7.386 (x_{\rm p} - 0.526)] + \frac{1}{2} \bigg]
\end{equation}
In order of appearance above, beginning with our Equation \ref{c_Prada}, these equations correspond to Equations 14-17, 13, 23a, 23b, 12, 18a, 18b, 19, 20 in \citet{Prada12}. The numerical values in these equations were obtained empirically from the simulations described in that work.
%---------- code ----------
\begin{lstlisting}
from clusterlensing import cofm
cofm.c_Prada([0.1, 0.5], [1e14, 1e15])
array([ 5.06733941,  5.99897362])
cofm.c_Prada([0.1, 0.1, 0.1], [1e13, 1e14, 1e15])
array([ 5.71130928, 5.06733941, 5.30163572])
\end{lstlisting}
%----------------------------
The last code example demonstrates the controversial feature of the \citet{Prada12} mass-concentration relation -- an upturn in concentration values for the highest mass halos -- in opposition to the canonical view that higher mass halos have lower concentrations \citep{nfw96, nfw97, Jing00, Bullock01}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\normalfont{\hcode{clusters.py}}}
\label{clusters}
The \code{clusters.py} module is designed to provide a catalog-level tool for calculating, tracking, and updating galaxy cluster properties and profiles, through structuring data from multiple clusters as an updatable Pandas Dataframe, and providing an intelligent interface to the other modules discussed in Sections \ref{nfw} and \ref{cofm}. This module contains a single class \code{ClusterEnsemble()}, as well as three functions, \code{mass_to_richness()}, \code{richness_to_mass()}, and \code{calc_delta_c()}.

The function \code{calc_delta_c()} takes a single input parameter, the cluster concentration \code{c200} (\emph{e.g.} as calculated by one of the functions in \code{cofm.py}), and returns the characteristic halo overdensity:
\begin{equation}
\delta_{\rm c} = \left( \frac{200}{3} \right) \frac{c_{200}^3}{\ln(1 + c_{200}) - c_{200}/(1 + c_{200})}.
\end{equation}
Both input and output are dimensionless here. For example, to convert a concentration value of $c_{200} = 5$ to $\delta_{\rm c}$, you could do:
%---------- code ----------
\begin{lstlisting}
from clusterlensing.clusters import calc_delta_c
calc_delta_c(5)
8694.8101906193315
\end{lstlisting}
%----------------------------

The pair of functions \code{mass_to_richness()} and \code{richness_to_mass()}, as their names imply, perform conversions between cluster mass and richness. The only required input parameter to \code{mass_to_richness()} is the \code{mass}, and likewise the only required input to \code{richness_to_mass()} is \code{richness}. The calculations assume a power-law form for the relationship between these variables:
\begin{equation}\label{massrich}
M_{200} = M_0 \left( \frac{N_{200}}{20} \right) ^ \beta.
\end{equation}
Here $M_0$ is the normalization, which defaults to $2.7 \times 10^{13}$, but can be changed in the call to either function by setting the \code{norm} keyword argument. The power-law slope $\beta = 1.4$ by default, but can be set by specifying the optional \code{slope} input parameter. When these functions are invoked by the \code{ClusterEnsemble()} class, they are applied to the particular mass definition $M_{200}$, and assume units of $M_{\odot}$. However the functions themselves do not assume a mass definition or unit, and can be generalized to any parameter (or type of richness) that has a power-law relationship with mass.
%---------- code ----------
\begin{lstlisting}
from clusterlensing.clusters import \
mass_to_richness, richness_to_mass
richness_to_mass(50)
97382243648736.9
mass_to_richness(97382243648736.9)
50.0
# specify other power-law parameters
richness_to_mass(20, slope=1.5, norm=1e14)
100000000000000.0
\end{lstlisting}
%----------------------------

The \code{ClusterEnsemble()} class creates, modifies and tracks a Pandas DataFrame containing the properties and attributes of many galaxy clusters at once. When given a new or updated cluster property, it calculates and updates all dependent cluster properties, treating each cluster (row) in the DataFrame as an individual object. This makes it easy to calculate the $\Sigma(R)$ and $\Delta\Sigma(R)$ weak lensing profiles for many different mass clusters at different redshifts, for example. In contrast to using the \code{SurfaceMassDensity()} class discussed in Section \ref{nfw}, the user only needs to specify the cluster redshifts and either of the mass or richness. If richness is supplied, then mass is calculated from it, assuming the form of Equation \ref{massrich} (which is customizable); if mass is specified instead, than the inverse relation is used to calculate richness. In either case the changes are propagated to any dependent variables:
%---------- code ----------
\begin{lstlisting}
from clusterlensing import ClusterEnsemble
z = [0.1,0.2,0.3]
c = ClusterEnsemble(z)
n200 = [20, 20, 20]
c.n200 = n200
# display cluster dataframe
c.dataframe
     z  n200          m200      r200      c200       delta_c        rs
0  0.1    20  2.700000e+13  0.612222  5.839934  12421.201995  0.104834
1  0.2    20  2.700000e+13  0.591082  5.644512  11480.644557  0.104718
2  0.3    20  2.700000e+13  0.569474  5.442457  10555.781440  0.104636
# specify mass directly
c.m200 = [1e13, 1e14, 1e15]
c.dataframe
     z        n200          m200      r200      c200       delta_c        rs
0  0.1    9.838141  1.000000e+13  0.439664  6.439529  15599.114356  0.068276
1  0.2   50.956400  1.000000e+14  0.914520  4.979102   8612.362538  0.183672
2  0.3  263.927382  1.000000e+15  1.898248  3.886853   4947.982895  0.488377
\end{lstlisting}
%----------------------------

The above examples also demonstrate that cluster masses are converted to concentrations and to characteristic halo overdensities. This assumes the default mass-concentration relation of the \code{c_DuttonMaccio()} form, or the user can instead specify another of the relations by setting the keyword \code{cm="Prada"} or \code{cm="Duffy"}, when the \code{ClusterEnsemble()} object is instantiated. Cosmology can also be specified upon instantiation, by setting the \code{cosmology} keyword to any of \code{"WMAP9"}, \code{"WMAP7"}, or \code{"WMAP5"}:
%---------- code ----------
\begin{lstlisting}
c = ClusterEnsemble(z, cm="Duffy", 
                    cosmology="WMAP5")
c.n200 = [20, 30, 40]
c.dataframe
     z  n200          m200      r200      c200      delta_c        rs
0  0.1    20  2.700000e+13  0.599910  4.520029  6920.955951  0.132723
1  0.2    30  4.763120e+13  0.702040  4.136873  5678.897592  0.169703
2  0.3    40  7.125343e+13  0.775889  3.851601  4849.836498  0.201446
\end{lstlisting}
%----------------------------
Instead of using the \code{dataframe} attribute, which retrieves the Pandas DataFrame object itself, it might be useful to use the \code{show()} method, which prints additional information to the screen, including assumptions of the mass-richness relation:
%---------- code ----------
\begin{lstlisting}
c.show()

Cluster Ensemble:

     z  n200          m200      r200      c200      delta_c        rs

0  0.1    20  2.700000e+13  0.599910  4.520029  6920.955951  0.132723
1  0.2    30  4.763120e+13  0.702040  4.136873  5678.897592  0.169703
2  0.3    40  7.125343e+13  0.775889  3.851601  4849.836498  0.201446

Mass-Richness Power Law:
M200 = norm * (N200 / 20) ^ slope
   norm: 2.7e+13 solMass
   slope: 1.4

# update the mass-richness parameters
# and show the resulting table
c.massrich_norm = 3e13
c.massrich_slope = 1.5
c.show()

Cluster Ensemble:
     z  n200          m200      r200      c200      delta_c        rs
0  0.1    20  3.000000e+13  0.621353  4.480202  6784.805438  0.138689
1  0.2    30  5.511352e+13  0.737028  4.086481  5526.615129  0.180358
2  0.3    40  8.485281e+13  0.822406  3.795500  4696.109606  0.216679

Mass-Richness Power Law:
M200 = norm * (N200 / 20) ^ slope
   norm: 3e+13 solMass
   slope: 1.5

\end{lstlisting}

%----------------------------
This example also demonstrates how the slope or normalization of the mass-richness relation can be altered, and the changes propagate from richness through to mass and other variables.

Then all the ingredients are in place to calculate halo profiles by invoking the \code{calc_nfw()} method, which interfaces to the \code{sigma_nfw()} and \code{deltasigma_nfw()} methods of the \code{SurfaceMassDensity()} class, and passes it the required inputs $\{ r_{\rm s}, \rho_{\rm crit}, \delta_{\rm c} \}$ for all the clusters behind the scenes. $\rho_{\rm crit}$ is calculated at every cluster redshift using the (default \code{astropy.cosmology.Planck13} or user-specified) cosmological model. The user must specify the desired radial bins \code{rbins} in Mpc.
%---------- code ----------
\begin{lstlisting}
import numpy as np
# create some logarithmic bins:
rmin, rmax = 0.1, 5. # Mpc
rbins = np.logspace(np.log10(rmin), 
                    np.log10(rmax), 
                    num = 8)
# calculate the profiles:
c.calc_nfw(rbins=rbins)
# profiles now exist as attributes:
c.sigma_nfw
<Quantity [[ 128.97156123, 62.58323349, 
27.01073105, 10.60607722, 3.88999449, 
1.36360964, 0.46464366, 0.15563814], 
[ 132.13989867, 64.10484454, 27.66159293, 
10.85990257, 3.98265113, 1.39599118, 
0.47565695, 0.15932308], [ 135.62272115, 
65.782882, 28.38138702, 11.14121765, 
4.08549675, 1.43196834, 0.48790043, 
0.16342108]] solMass / pc2>
c.deltasigma_nfw
<Quantity [[ 105.3190568 , 72.43842908, 
43.74538085, 23.44005481, 11.37085955, 
5.10385452, 2.16011364, 0.87479771], 
[ 107.98098357, 74.25022426, 44.82825347, 
24.01505305, 11.64776118, 5.22744541, 
2.21219956, 0.89582394], [ 110.88173507, 
76.23087398, 46.01581348, 24.64741078, 
11.95297965, 5.36391529, 2.26978998, 
0.91909571]] solMass / pc2>
\end{lstlisting}
%----------------------------

Similar to the direct use of \code{SurfaceMassDensity()}, discussed in Section \ref{nfw}, the miscentered profiles can be calculated from the \code{calc_nfw()} method, by supplying the optional \code{offsets} keyword with an array-like object of length equal to the number of clusters, where each element is the width of the offset distribution in Mpc ($\sigma_{\rm off}$ in Equation \ref{PofR}).
%---------- code ----------
\begin{lstlisting}
c.calc_nfw(rbins=rbins, offsets=[0.3,0.3,0.3])
#the offset sigma profile is now:
c.sigma_nfw
<Quantity [[ 42.50844685, 39.74291121, 
32.29894213, 18.50988719, 6.16284894, 
1.89335218, 0.62609991, 0.20840423], 
[ 68.10228964, 63.87901872, 52.56539317, 
31.20890672, 11.17821854, 3.5884285, 
1.20745376, 0.40574057], [ 95.16077234, 
89.48298631, 74.29328561, 45.24074628, 
17.06333763, 5.66481165, 1.93408383, 
0.65518747]] solMass / pc2>
\end{lstlisting}
%----------------------------

Although \code{SurfaceMassDensity()} from the \code{nfw.py} module, and \code{ClusterEnsemble().calc_nfw()} from the \code{clusters.py} module, are both capable of computing the same $\Sigma(R)$ and $\Delta\Sigma(R)$ profiles, each require different forms of input which would make sense for different use cases. For the studies in \citet{Ford15}, \citet{Ford14}, and \citet{Ford12}, the authors wanted do the profile computations for many clusters at once, while varying the mass and the miscentering offset distribution during the process of fitting the model to the data. What was known were the redshifts and mass proxies (cluster richness in \citealt{Ford15} and \citealt{Ford14}, and a previous mass estimate in \citealt{Ford12}), and mass-concentration relations from the literature, so the \code{ClusterEnsemble()} framework made sense. However, if someone wanted to simply calculate the NFW profiles according to the \citet{Wright00} formulation, then they might prefer to use \code{SurfaceMassDensity()} as a tool to get profiles directly from the NFW and cosmological parameters $r_{\rm s}$, $\delta_{\rm c}$, and $\rho_{\rm crit}(z)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Relation to Existing Code}

Mention related public code that I could find.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Examples}
\label{ex}
Some more detailed examples.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Future Development}
\label{future}

Plans for the future.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Summary}
\label{summary}

Summary goes here.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\vspace{10.pt}

\section*{Acknowledgements}
The authors are grateful for funding from the Washington Research Foundation Fund for Innovation in Data-Intensive Discovery and the Moore/Sloan Data Science Environments Project at the University of Washington. This project makes use of Astropy, a community-developed core Python package for Astronomy (Astropy Collaboration, 2013), \url{http://www.astropy.org}.


\bibliographystyle{apj}
\bibliography{References}

\end{document}
